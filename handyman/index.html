<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; background: #1a1a2e; overflow: hidden; touch-action: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui-container {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 85%; max-width: 400px; z-index: 100; text-align: center; pointer-events: none;
        }
        #progress-wrapper {
            width: 100%; height: 12px; background: rgba(0,0,0,0.6);
            border: 2px solid #fff; border-radius: 10px; overflow: hidden; display: none; margin-top: 10px;
        }
        #progress-bar { width: 0%; height: 100%; background: #f1c40f; box-shadow: 0 0 10px #f1c40f; }
        #info-text { 
            color: white; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); 
            font-size: 16px; background: rgba(0,0,0,0.4); padding: 8px 20px; border-radius: 20px;
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>

<div id="ui-container">
    <div id="info-text">Натисніть на дверний упор для ремонту</div>
    <div id="progress-wrapper"><div id="progress-bar"></div></div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const tg = window.Telegram.WebApp;
    tg.expand();

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- Configuration & Assets ---
    const CONFIG = {
        tileW: 80, tileH: 40,
        houseH: 750, tambourH: 120,
        colors: {
            ground1: "#bdc3c7", ground2: "#a3aeb1",
            wall: "#7f8c8d", wallFront: "#bdc3c7",
            glass: "rgba(135, 206, 235, 0.4)",
            anthracite: "#2c3e50",
            white: "#ffffff",
            skinColor: "#ffdbac",
            capColor: "#0f172a",
			logoColor: "#ffffff"
        }
    };

    // Pre-render noise texture for grain effect
    const noiseCanvas = document.createElement('canvas');
    noiseCanvas.width = 64; noiseCanvas.height = 64;
    const nCtx = noiseCanvas.getContext('2d');
    for(let i=0; i<noiseCanvas.width; i++) {
        for(let j=0; j<noiseCanvas.height; j++) {
            const val = Math.floor(Math.random() * 20);
            nCtx.fillStyle = `rgba(0,0,0,${val/255})`;
            nCtx.fillRect(i,j,1,1);
        }
    }
    const noisePattern = ctx.createPattern(noiseCanvas, 'repeat');

    const player = {
        x: 5, y: 5, tx: 5, ty: 5,
        state: 'idle', isBack: false, animFrame: 0, speed: 0.07,
        targetLoc: { x: 2.0, y: 2.5 }
    };

    let particles = [];
    const bushDataL = [];
    const bushDataR = [];

    // --- Initialization ---
    function initBushesL() {
        for (let gy = -9; gy <= 1; gy += 0.4) {
            if (gy < .9 || gy > 4.5) {
                const jitterY = (Math.random() - 0.5) * 0.5;
                const baseSize = 12 + Math.random() * 8;
                const blobs = Array.from({length: 5}, () => ({
                    ox: (Math.random() - 0.5) * baseSize,
                    oy: (Math.random() - 0.5) * baseSize - 5,
                    r: baseSize * (0.5 + Math.random() * 0.5),
                    color: ['#2d4a27', '#3a6d32', '#4e8344'][Math.floor(Math.random() * 3)],
                    hasHighlight: Math.random() > 0.6
                }));
                bushDataL.push({ gx: 0.5, gy: gy + jitterY, baseSize, blobs });
            }
        }
    }
	
	function initBushesR() {
        for (let gy = 4; gy <= 9; gy += 0.4) {
            if (gy < 0.5 || gy > 3.5) {
                const jitterY = (Math.random() - 0.5) * 0.5;
                const baseSize = 12 + Math.random() * 8;
                const blobs = Array.from({length: 5}, () => ({
                    ox: (Math.random() - 0.5) * baseSize,
                    oy: (Math.random() - 0.5) * baseSize - 5,
                    r: baseSize * (0.5 + Math.random() * 0.5),
                    color: ['#2d4a27', '#3a6d32', '#4e8344'][Math.floor(Math.random() * 3)],
                    hasHighlight: Math.random() > 0.6
                }));
                bushDataR.push({ gx: 0.5, gy: gy + jitterY, baseSize, blobs });
            }
        }
    }

    const toScreen = (gx, gy, gz = 0) => ({
        x: canvas.width / 2 + (gx - gy) * (CONFIG.tileW / 2),
        y: canvas.height / 1.8 + (gx + gy) * (CONFIG.tileH / 2) - gz
    });

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.onresize = resize;
    resize();
    initBushesL();
    initBushesR();

    // --- Drawing Helpers ---
    function drawIsoPath(points, fill, stroke, weight = 1) {
        ctx.beginPath();
        points.forEach((pt, i) => {
            const s = toScreen(pt.gx, pt.gy, pt.gz || 0);
            i === 0 ? ctx.moveTo(s.x, s.y) : ctx.lineTo(s.x, s.y);
        });
        ctx.closePath();
        if (fill) { ctx.fillStyle = fill; ctx.fill(); }
        if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = weight; ctx.stroke(); }
        
        // Apply grain overlay
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fillStyle = noisePattern;
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
    }
	
    function drawWorld() {
        // 1. Ground with Screen Culling
        const range = 22; 
        for (let x = -2; x < 15; x++) {
            for (let y = -range; y < range; y++) {
                const p = toScreen(x, y);
                if (p.x < -80 || p.x > canvas.width + 80 || p.y < -40 || p.y > canvas.height + 40) continue;
                
                ctx.fillStyle = (x + y) % 2 === 0 ? CONFIG.colors.ground1 : CONFIG.colors.ground2;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x + CONFIG.tileW/2, p.y + CONFIG.tileH/2);
                ctx.lineTo(p.x, p.y + CONFIG.tileH);
                ctx.lineTo(p.x - CONFIG.tileW/2, p.y + CONFIG.tileH/2);
                ctx.fill();
            }
        }

        // 2. Ambient Occlusion (Soft shadow at wall base)
        const wallStart = toScreen(0, -10), wallEnd = toScreen(0, 10);
        const gradShadow = ctx.createLinearGradient(wallStart.x, wallStart.y, wallStart.x + 40, wallStart.y + 20);
        gradShadow.addColorStop(0, 'rgba(0,0,0,0.2)');
        gradShadow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradShadow;
        ctx.beginPath();
        ctx.moveTo(wallStart.x, wallStart.y); ctx.lineTo(wallEnd.x, wallEnd.y);
        ctx.lineTo(wallEnd.x + 20, wallEnd.y + 10); ctx.lineTo(wallStart.x + 20, wallStart.y + 10);
        ctx.fill();

        // 3. Main Wall with Vertical Gradient
        const wallGrad = ctx.createLinearGradient(0, canvas.height/1.8 - CONFIG.houseH, 0, canvas.height/1.8);
        wallGrad.addColorStop(0, "#5f6c6d");
        wallGrad.addColorStop(1, CONFIG.colors.wall);
        drawIsoPath([{gx:0,gy:-10,gz:0}, {gx:0,gy:10,gz:0}, {gx:0,gy:10,gz:CONFIG.houseH}, {gx:0,gy:-10,gz:CONFIG.houseH}], wallGrad);

        // Windows
        for (let floor = -1; floor < 6; floor++) {
            const floorZ = CONFIG.tambourH + 15 + (floor * 120);
            [ -3.5, -0.5, 2.5, 5.5 ].forEach(gy => {
                if(gy === 2.5 && floor === -1) return;
                drawRealisticWindow(0, gy, floorZ, 0.6, 80);
            });
        }
		
        drawStaticBushes(bushDataL);

        // 4. Tambour Structure
        const th = CONFIG.tambourH;
        // Floor shadow inside
        drawIsoPath([{gx:0,gy:1},{gx:1,gy:1},{gx:1,gy:4},{gx:0,gy:4}], "#2c3e50");
        drawIsoPath([{gx:0,gy:1,gz:0},{gx:0,gy:4,gz:0},{gx:0,gy:4,gz:th},{gx:0,gy:1,gz:th}], "#446566"); // back
        
        // Walls
        drawIsoPath([{gx:1,gy:4,gz:0},{gx:0,gy:4,gz:0},{gx:0,gy:4,gz:th},{gx:1,gy:4,gz:th}], "#859596"); // Right
        drawIsoPath([{gx:0,gy:1,gz:0},{gx:1,gy:1,gz:0},{gx:1,gy:1,gz:th},{gx:0,gy:1,gz:th}], "#859596"); // Left
        
        // Front Pillars
        drawIsoPath([{gx:1,gy:1,gz:0}, {gx:1,gy:2.05,gz:0}, {gx:1,gy:2.05,gz:th}, {gx:1,gy:1,gz:th}], CONFIG.colors.wallFront);
        drawIsoPath([{gx:1,gy:2.95,gz:0}, {gx:1,gy:4,gz:0}, {gx:1,gy:4,gz:th}, {gx:1,gy:2.95,gz:th}], CONFIG.colors.wallFront);
        drawIsoPath([{gx:1,gy:2.05,gz:110}, {gx:1,gy:2.95,gz:110}, {gx:1,gy:2.95,gz:th}, {gx:1,gy:2.05,gz:th}], CONFIG.colors.wallFront);

        // Glass
        drawIsoPath([{gx:1,gy:1.1,gz:5},{gx:1,gy:2,gz:5},{gx:1,gy:2,gz:110},{gx:1,gy:1.1,gz:110}], CONFIG.colors.glass, CONFIG.colors.anthracite, 1);
        drawIsoPath([{gx:1,gy:3,gz:5},{gx:1,gy:3.9,gz:5},{gx:1,gy:3.9,gz:110},{gx:1,gy:3,gz:110}], CONFIG.colors.glass, CONFIG.colors.anthracite, 1);
		
		drawStaticBushes(bushDataR);

        // Door
        const hinge = toScreen(1, 2.05, 0), edge = toScreen(1.7, 2.05, 0);
        ctx.fillStyle = "rgba(135, 206, 235, 0.5)";
        ctx.beginPath();
        ctx.moveTo(hinge.x, hinge.y); ctx.lineTo(edge.x, edge.y);
        ctx.lineTo(edge.x, edge.y - 110); ctx.lineTo(hinge.x, hinge.y - 110);
        ctx.fill(); ctx.strokeStyle = CONFIG.colors.anthracite; ctx.stroke();
		
        // Handle & Stand
		ctx.beginPath(); ctx.moveTo(edge.x - 3, edge.y - 55); ctx.lineTo(edge.x - 3, edge.y - 45); ctx.stroke();
		ctx.beginPath(); ctx.strokeStyle = "white"; ctx.moveTo(edge.x, edge.y - 10); ctx.lineTo(edge.x - 3, edge.y +3); ctx.stroke();

        drawIsoPath([{gx:0,gy:1,gz:th},{gx:1,gy:1,gz:th},{gx:1,gy:4,gz:th},{gx:0,gy:4,gz:th}], "#f5faff");
    }

    function drawRealisticWindow(gx, gy, gz, width, height) {
        const frame = [{gx, gy: gy - width, gz}, {gx, gy: gy + width, gz}, {gx, gy: gy + width, gz: gz + height}, {gx, gy: gy - width, gz: gz + height}];
        drawIsoPath(frame, CONFIG.colors.anthracite);
        const glass = [{gx, gy: gy - width + 0.1, gz: gz + 3}, {gx, gy: gy + width - 0.1, gz: gz + 3}, {gx, gy: gy + width - 0.1, gz: gz + height - 3}, {gx, gy: gy - width + 0.1, gz: gz + height - 3}];
        drawIsoPath(glass, CONFIG.colors.glass);
        // Reflection
        const s1 = toScreen(gx, gy - width + 0.4, gz + height - 10);
        const s2 = toScreen(gx, gy + width - 0.4, gz + 10);
        ctx.strokeStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    }

    function drawStaticBushes(bushData) {
        bushData.forEach(bush => {
            const pos = toScreen(bush.gx, bush.gy);
            ctx.fillStyle = "rgba(0,0,0,0.15)";
            ctx.beginPath(); ctx.ellipse(pos.x, pos.y + 4, bush.baseSize, bush.baseSize/2, 0, 0, Math.PI*2); ctx.fill();

            bush.blobs.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.beginPath(); ctx.arc(pos.x + b.ox, pos.y + b.oy, b.r, 0, Math.PI*2); ctx.fill();
                if (b.hasHighlight) {
                    ctx.fillStyle = "rgba(255,255,255,0.15)";
                    ctx.beginPath(); ctx.arc(pos.x + b.ox + 2, pos.y + b.oy - 2, 3, 0, Math.PI*2); ctx.fill();
                }
            });
        });
    }

    function drawWorker() {
    const pos = toScreen(player.x, player.y);
    if (player.state === 'walking') player.animFrame = (player.animFrame + 0.15) % 4;
    if (player.state === 'working') player.animFrame = (player.animFrame + 0.25) % 2;
    const frame = Math.floor(player.animFrame);

    ctx.save();
    
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.beginPath(); 
    ctx.ellipse(pos.x, pos.y + 16, 16, 8, 0, 0, Math.PI * 2); 
    ctx.fill();

    // Body & Legs
    ctx.fillStyle = "#16213e";
    const lY = (player.state === 'walking' && frame % 2 === 0) ? -6 : 0;
    const rY = (player.state === 'walking' && frame % 2 === 1) ? -6 : 0;
    
    // Rects: [x, y, width, height] -> All values * 2
    ctx.fillRect(pos.x - 14, pos.y - 20 + lY, 10, 31); // Left leg
    ctx.fillRect(pos.x + 4, pos.y - 20 + rY, 10, 31);  // Right leg
    ctx.fillRect(pos.x - 18, pos.y - 56, 36, 40);      // Torso

    // Logo on back
    if (player.isBack || player.state === 'working') {
        ctx.fillStyle = CONFIG.colors.logoColor;
        ctx.font = "bold 22px Arial"; // Doubled font
        ctx.textAlign = "center";
        ctx.fillText("A", pos.x, pos.y - 32);
    }

    // Arms
    ctx.fillStyle = CONFIG.colors.skinColor;
    let wobble = (player.state === 'working') ? (frame === 0 ? -4 : 4) : 0;
    ctx.fillRect(pos.x - 26, pos.y - 48 + wobble, 8, 20); // Left arm
    ctx.fillRect(pos.x + 18, pos.y - 48 - wobble, 8, 20); // Right arm
    
    // Screwdriver
    if (player.state === 'working') {
        ctx.fillStyle = "#7f8c8d";
        ctx.fillRect(pos.x - 28, pos.y - 60 + wobble, 4, 16);
    }

    // Head (Radius 6 * 2 = 12)
    ctx.beginPath(); 
    ctx.fillStyle = CONFIG.colors.skinColor;
    ctx.arc(pos.x, pos.y - 68, 12, 0, Math.PI * 2); 
    ctx.fill();

    // Cap (Size 7x5 * 2 = 14x10)
    ctx.beginPath(); 
    ctx.fillStyle = CONFIG.colors.capColor;
    ctx.ellipse(pos.x, pos.y - 74, 14, 10, 0, 0, Math.PI * 2); 
    ctx.fill();
    
    // Cap Brim
    ctx.beginPath();
    if (player.isBack || player.state === 'working') {
        ctx.ellipse(pos.x - 8, pos.y - 74, 10, 4, Math.PI / 4, 0, Math.PI * 2);
    } else {
        ctx.ellipse(pos.x + 8, pos.y - 70, 12, 4, -Math.PI / 8, 0, Math.PI * 2);
    }
    ctx.fill();

    ctx.restore();
}

    function startWork() {
        player.state = 'working';
        player.x = player.targetLoc.x; player.y = player.targetLoc.y;
        const wrapper = document.getElementById('progress-wrapper');
        const bar = document.getElementById('progress-bar');
        const text = document.getElementById('info-text');
        wrapper.style.display = 'block';
        
        let start = Date.now();
        const duration = 3000;
        const workInterval = setInterval(() => {
            let progress = Math.min((Date.now() - start) / duration, 1);
            bar.style.width = (progress * 100) + '%';
            text.innerText = `Ремонт: ${(progress * 2).toFixed(1)} люд/год`;
            
            const pPos = toScreen(player.x, player.y);
            particles.push({x: pPos.x+10, y: pPos.y-5, vx: Math.random()-0.5, vy: -Math.random(), a: 1});

            if (progress >= 1) {
                clearInterval(workInterval);
                player.state = 'idle';
                wrapper.style.display = 'none';
                text.innerText = "Готово! ✅ (+ 2.0 люд/год)";
                if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
            }
        }, 50);
    }

function update() {
    if (player.state === 'walking') {
        let dx = player.tx - player.x, dy = player.ty - player.y;
        let dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0.1) {
            let nx = player.x + (dx / dist) * player.speed;
            let ny = player.y + (dy / dist) * player.speed;

            // 1. Convert predicted grid position to screen position
            const screenPos = toScreen(nx, ny);
            
            // 2. Define safety margins (since worker is 2x bigger)
            const marginX = 40; // Horizontal width of worker
            const marginYTop = 80; // Height of worker
            const marginYBot = 20; // Feet/Shadow area

            // 3. Check Screen Boundaries
            let canMoveX = screenPos.x > marginX && screenPos.x < canvas.width - marginX;
            let canMoveY = screenPos.y > marginYTop && screenPos.y < canvas.height - marginYBot;

            // 4. Simple wall collision (gx < 1.1)
            if (nx < 1.1) canMoveX = false;

            // Apply movement only if within screen and wall bounds
            if (canMoveX) player.x = nx;
            if (canMoveY) player.y = ny;

            player.isBack = (dx + dy < 0);
        } else {
            player.state = 'idle';
            const dX = player.x - player.targetLoc.x;
            const dY = player.y - player.targetLoc.y;
            const distToWork = Math.sqrt(dX * dX + dY * dY);
            
            if (distToWork < 0.5) {
                startWork();
            }
        }
    }
        particles = particles.filter(p => { p.x += p.vx; p.y += p.vy; p.a -= 0.03; return p.a > 0; });
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawWorld();
        drawWorker();
        particles.forEach(p => {
            ctx.fillStyle = `rgba(180, 180, 180, ${p.a})`;
            ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI*2); ctx.fill();
        });
        requestAnimationFrame(update);
    }

    canvas.onclick = (e) => {
    if (player.state === 'working') return;
    const mx = e.clientX - canvas.width / 2;
    const my = e.clientY - canvas.height / 1.8;
    
    // Calculate raw target
    let targetX = (my / (CONFIG.tileH/2) + mx / (CONFIG.tileW/2)) / 2;
    let targetY = (my / (CONFIG.tileH/2) - mx / (CONFIG.tileW/2)) / 2;

    // Boundary check for the click itself (don't set a target off-screen)
    const targetScreen = toScreen(targetX, targetY);
    if (targetScreen.x < 20 || targetScreen.x > canvas.width - 20 || 
        targetScreen.y < 50 || targetScreen.y > canvas.height - 20) {
        return; // Ignore clicks too close to edge
    }

    player.tx = Math.max(1.2, targetX);
    player.ty = targetY;
    player.state = 'walking';
};

    update();
</script>
</body>
</html>
